Go基础知识：
  1.变量和常量
    基本类型：
        bool
        数字类型
          int8, int16, int32, int64, int
          uint8, uint16, uint32, uint64, uint
          float32, float64
          complex64, complex128
          byte
          rune
          byte 是 uint8 的别名。
          rune 是 int32 的别名。
        string
    Go 有着非常严格的强类型特征。Go 没有自动类型提升或类型转换。
    常量不能再重新赋值为其他的值。
    常量的值会在编译的时候确定。因为函数调用发生在运行时，所以不能将函数的返回值赋值给常量。
    常量没有任何类型。无类型的常量有一个与它们相关联的默认类型，并且当且仅当一行代码需要时才提供它。
    数字常量可以在表达式中自由混合和匹配，只有当它们被分配给变量或者在需要类型的代码中的任何地方使用时，才需要类型。
    
  2.函数和包
    多返回值、命名返回值、空白符
    包用于组织 Go 源代码，提供了更好的可重用性与可读性。
    属于某一个包的源文件都应该放置于一个单独命名的文件夹里。按照 Go 的惯例，应该用包名命名该文件夹。
    在 Go 中，任何以大写字母开头的变量或者函数都是被导出的名字。其它包只能访问被导出的函数和变量。
    所有包都可以包含一个 init 函数。init 函数不应该有任何返回值类型和参数，在我们的代码中也不能显式地调用它。
    init 函数可用于执行初始化任务，也可用于在开始执行之前验证程序的正确性。
    包的初始化顺序如下：
        首先初始化包级别（Package Level）的变量
        紧接着调用 init 函数。包可以有多个 init 函数（在一个文件或分布于多个文件中），它们按照编译器解析它们的顺序进行调用。
    如果一个包导入了另一个包，会先初始化被导入的包。尽管一个包可能会被导入多次，但是它只会被初始化一次。
    导入了包，却不在代码中使用它，这在 Go 中是非法的。当这么做时，编译器是会报错的。其原因是为了避免导入过多未使用的包，从而导致编译时间显著增加。
    然而，在程序开发的活跃阶段，又常常会先导入包，而暂不使用它。遇到这种情况就可以使用空白标识符 _。
    var _ = rectangle.Area 这一行屏蔽了错误。我们应该了解这些错误屏蔽器（Error Silencer）的动态，在程序开发结束时就移除它们，包括那些还没有使用过的包。
    由此建议在 import 语句下面的包级别范围中写上错误屏蔽器。
    有时候我们导入一个包，只是为了确保它进行了初始化，而无需使用包中的任何函数或变量。这种情况也可以使用空白标识符。
    
  3.if/else和循环和switch
    if 还有另外一种形式，它包含一个 statement 可选语句部分，该组件在条件判断之前运行。它的语法是
      if statement; condition {  
      }
    else 语句应该在 if 语句的大括号 } 之后的同一行中。如果不是，编译器会不通过。出错的原因是 Go 语言的分号是自动插入。
    在 Go 语言规则中，它指定在 } 之后插入一个分号，如果这是该行的最终标记。因此，在if语句后面的 } 会自动插入一个分号。
    ----------------------------------------------------------------------------------------------------
    for 是 Go 语言唯一的循环语句。Go 语言中并没有其他语言比如 C 语言中的 while 和 do while 循环。
    for initialisation; condition; post {  
    }
    这三个组成部分，即初始化，条件和 post 都是可选的。
    无限循环的语法是：
    for {  
    }
    ----------------------------------------------------------------------------------------------------
    switch 是一个条件语句，用于将表达式的值与可能匹配的选项列表进行比较，并根据匹配情况执行相应的代码块。
    它可以被认为是替代多个 if else 子句的常用方式。
    在选项列表中，case 不允许出现重复项。
    default 不一定只能出现在 switch 语句的最后，它可以放在 switch 语句的任何地方。
    在表达式求值之前，switch 可以选择先执行一个语句。
    多表达式判断：通过用逗号分隔，可以在一个 case 中包含多个表达式。
    无表达式的 switch：在 switch 语句中，表达式是可选的，可以被省略。这种类型的 switch 语句可以替代多个 if else 子句。
    如果省略表达式，则表示这个 switch 语句等同于 switch true，并且每个 case 表达式都被认定为有效，相应的代码块也会被执行。
    在 Go 中，每执行完一个 case 后，会从 switch 语句中跳出来，不再做后续 case 的判断和执行。
    使用 fallthrough 语句可以在已经执行完成的 case 之后，把控制权转移到下一个 case 的执行代码中。
    fallthrough 语句应该是 case 子句的最后一个语句。如果它出现在了 case 语句的中间，编译器将会报错：fallthrough statement out of place
    
  4.数组和切片
    数组是同一类型元素的集合。Go 语言中不允许混合不同类型的元素，如果是 interface{} 类型数组，可以包含任意类型。
    一个数组的表示形式为 [n]T。n 表示数组中元素的数量，T 代表每个元素的类型。元素的数量 n 也是该类型的一部分。
    可以使用不同的方式来声明数组：
        var a[3]int 声明了一个长度为 3 的整型数组。数组中的所有元素都被自动赋值为数组类型的零值。
        在这种情况下，a 是一个整型数组，因此 a 的所有元素都被赋值为 0，即 int 型的零值。
        简略声明：在简略声明中，不需要将数组中所有的元素赋值。
            a := [3]int{12, 78, 50}
            a := [3]int{12}
       甚至可以忽略声明数组的长度，并用 ... 代替，让编译器为你自动计算长度。
            a := [...]int{12, 78, 50}
       数组的大小是类型的一部分。因此 [5]int 和 [25]int 是不同类型。数组不能调整大小，不要担心这个限制，因为 slices 的存在能解决这个问题。
    Go 中的数组是值类型而不是引用类型。这意味着当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本。
    如果对新变量进行更改，则不会影响原始数组。同样，当数组作为参数传递给函数时，它们是按值传递，而原始数组保持不变。
    Go 提供了一种更好、更简洁的方法，通过使用 for 循环的 range 方法来遍历数组。range 返回索引和该索引处的值。
    如果你只需要值并希望忽略索引，则可以通过用 _ 空白标识符替换索引来执行。同样值也可以被忽略。
    这就是数组，尽管数组看上去似乎足够灵活，但是它们具有固定长度的限制，不可能增加数组的长度。这就要用到 切片 了。
    事实上，在 Go 中，切片比传统数组更常见。
    ----------------------------------------------------------------------------------------------------
    切片是由数组建立的一种方便、灵活且功能强大的包装（Wrapper）。切片本身不拥有任何数据。它们只是对现有数组的引用。
    带有 T 类型元素的切片由 []T 表示：
        a := [5]int{76, 77, 78, 79, 80}
        var b []int = a[1:4]
    另一种创建切片的方法：
        c := []int{6, 7, 8}
    切片自己不拥有任何数据。它只是底层数组的一种表示。对切片所做的任何修改都会反映在底层数组中。
    当多个切片共用相同的底层数组时，每个切片所做的更改将反映在数组中。
    切片的长度是切片中的元素数。切片的容量是从创建切片索引开始的底层数组中元素数。切片可以重置其容量。
    func make（[]T，len，cap）[]T 通过传递类型，长度和容量来创建切片。
    容量是可选参数, 默认值为切片长度。make 函数创建一个数组，并返回引用该数组的切片。
        i := make([]int, 5, 5)
    切片是动态的，使用 append 可以将新元素追加到切片上。append 函数的定义是 func append（s[]T，x ... T）[]T。
    x ... T 在函数定义中表示该函数接受参数 x 的个数是可变的。这些类型的函数被称为可变参数函数。
    当新的元素被添加到切片时，会创建一个新的数组。现有数组的元素被复制到这个新数组中，并返回这个新数组的新切片引用。现在新切片的容量是旧切片的两倍。
    切片类型的零值为 nil。一个 nil 切片的长度和容量为 0。可以使用 append 函数将值追加到 nil 切片。
    也可以使用 ... 运算符将一个切片添加到另一个切片。 
    切片包含长度、容量和指向数组第零个元素的指针。
    我们可以认为，切片在内部可由一个结构体类型表示。这是它的表现形式：
        type slice struct {  
            Length        int
            Capacity      int
            ZerothElement *byte
        }
    当切片传递给函数时，即使它通过值传递，指针变量也将引用相同的底层数组。
    内存优化：
        切片持有对底层数组的引用。只要切片在内存中，数组就不能被垃圾回收。在内存管理方面，这是需要注意的。
        假设我们有一个非常大的数组，我们只想处理它的一小部分。然后，我们由这个数组创建一个切片，并开始处理切片。
        这里需要重点注意的是，在切片引用时数组仍然存在内存中。
        一种解决方法是使用 copy 函数 func copy(dst，src[]T)int 来生成一个切片的副本。这样我们可以使用新的切片，原始数组可以被垃圾回收。
  
  5.可变参数函数
    可变参数函数是一种参数个数可变的函数。
    如果函数最后一个参数被记作 ...T ，这时函数可以接受任意个 T 类型参数作为最后一个参数。
    请注意只有函数的最后一个参数才允许是可变的。
    可变参数函数的工作原理是把可变参数转换为一个新的切片。
    有一个可以直接将切片传入可变参数函数的语法糖，你可以在在切片后加上 ... 后缀。如果这样做，切片将直接传入函数，不再创建新的切片。
    
  6.map
    map 是在 Go 中将值（value）与键（key）关联的内置类型。通过相应的键可以获取到值。
    通过向 make 函数传入键和值的类型，可以创建 map。make(map[type of key]type of value) 是创建 map 的语法。
    personSalary := make(map[string]int)
    map 的零值是 nil。如果你想添加元素到 nil map 中，会触发运行时 panic。因此 map 必须使用 make 函数初始化。
    也可以在声明的时候初始化 map:
        personSalary := map[string]int {
            "steve": 12000,
            "jamie": 15000,
        }
    键不一定只能是 string 类型。所有可比较的类型，如 boolean，interger，float，complex，string 等，都可以作为键。
    获取 map 元素的语法是 map[key]。获取一个不存在的元素，map 会返回该元素类型的零值。
    获取 map 中某个 key 是否存在的语法：
        value, ok := map[key]
    如果 ok 是 true，表示 key 存在，key 对应的值就是 value ，反之表示 key 不存在。
    遍历 map 中所有的元素需要用 for range 循环。有一点很重要，当使用 for range 遍历 map 时，不保证每次执行程序获取的元素顺序相同。
    删除 map 中 key 的语法是 delete(map, key)。这个函数没有返回值。
    获取 map 的长度使用 len 函数。
    和 slices 类似，map 也是引用类型。当 map 作为函数参数传递时也会发生同样的情况。函数中对 map 的任何修改，对于外部的调用都是可见的。
    map 之间不能使用 == 操作符判断，== 只能用来检查 map 是否为 nil。
    
  7.字符串
    由于和其他语言相比，字符串在 Go 语言中有着自己特殊的实现，因此在这里需要被特别提出来。
    Go 语言中的字符串是一个字节切片。把内容放在双引号""之间，我们可以创建一个字符串。Go 中的字符串是兼容 Unicode 编码的，并且使用 UTF-8 进行编码。
    在 UTF-8 编码中，一个代码点可能会占用超过一个字节的空间。rune 能帮我们解决这个难题。
    rune 是 Go 语言的内建类型，它也是 int32 的别称。在 Go 语言中，rune 表示一个代码点。代码点无论占用多少个字节，都可以用一个 rune 来表示。
    字符串使用 for range 循环。
    用字节切片构造字符串：
       byteSlice := []byte{0x43, 0x61, 0x66, 0xC3, 0xA9}
       str := string(byteSlice)
    用 rune 切片构造字符串
       runeSlice := []rune{0x0053, 0x0065, 0x00f1, 0x006f, 0x0072}
       str := string(runeSlice)
    utf8 package 包中的 func RuneCountInString(s string) (n int) 方法用来获取字符串的长度。
    Go 中的字符串是不可变的。一旦一个字符串被创建，那么它将无法被修改。
    为了修改字符串，可以把字符串转化为一个 rune 切片。然后这个切片可以进行任何想要的改变，然后再转化为一个字符串。
       s[0] = 'a' //any valid unicode character within single quote is a rune
   
  8.指针
    指针是一种存储变量内存地址（Memory Address）的变量。
    指针变量的类型为 *T，该指针指向一个 T 类型的变量。
    指针的零值是 nil。
    指针的解引用可以获取指针所指向的变量的值。将 a 解引用的语法是 *a。
    向函数传递指针参数：
        向函数传递一个数组指针参数，并在函数内修改数组。尽管它是有效的，但却不是 Go 语言惯用的实现方式。我们最好使用切片来处理。
    Go 并不支持其他语言（例如 C）中的指针运算。
  
  9.结构体
    结构体是用户定义的类型，表示若干个字段（Field）的集合。有时应该把数据整合在一起，而不是让这些数据没有联系。这种情况下可以使用结构体。
    命名的结构体：
       type Employee struct {
          firstName, lastName string
          age, salary         int
       }
    声明结构体时也可以不用声明一个新类型，这样的结构体类型称为 匿名结构体（Anonymous Structure）。
       var employee struct {
          firstName, lastName string
          age int
       }
    当定义好的结构体并没有被显式地初始化时，该结构体的字段将默认赋为零值。
    当然还可以为某些字段指定初始值，而忽略其他字段。这样，忽略的字段名会赋值为零值。
    点号操作符 . 用于访问结构体的字段。
    结构体的指针：
        Go 语言允许我们在访问 firstName 字段时，可以使用 emp8.firstName 来代替显式的解引用 (*emp8).firstName。
    当我们创建结构体时，字段可以只有类型，而没有字段名。这样的字段称为匿名字段（Anonymous Field）。
       type Person struct {  
          string
          int
       }
    虽然匿名字段没有名称，但其实匿名字段的名称就默认为它的类型。所以 Person 结构体有两个名为 string 和 int 的字段。
    结构体的字段有可能也是一个结构体。这样的结构体称为嵌套结构体。
    如果是结构体中有匿名的结构体类型字段，则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。
    如果结构体名称以大写字母开头，则它是其他包可以访问的导出类型（Exported Type）。同样，如果结构体里的字段首字母大写，它也能被其他包访问到。
    结构体是值类型。
    如果它的每一个字段都是可比较的，则该结构体也是可比较的。
    如果两个结构体变量的对应字段相等，则这两个变量也是相等的。
  
  10.方法
     方法其实就是一个函数，在 func 这个关键字和方法名中间加入了一个特殊的接收器类型。
     接收器可以是结构体类型或者是非结构体类型。接收器是可以在方法的内部访问的。
         func (t Type) methodName(parameter list) {
         } 
     Go 不是纯粹的面向对象编程语言，而且Go不支持类。因此，基于类型的方法是一种实现和类相似行为的途径。
     相同的名字的方法可以定义在不同的类型上，而相同名字的函数是不被允许的。
     指针接收器与值接收器：值接收器和指针接收器之间的区别在于，在指针接收器的方法内部的改变对于调用者是可见的，然而值接收器的情况不是这样的。
     Go语言让我们可以直接使用 e.changeAge(51)。e.changeAge(51) 会自动被Go语言解释为 (&e).changeAge(51)。
     一般来说，
         指针接收器可以使用在：对方法内部的接收器所做的改变应该对调用者可见时。
         指针接收器也可以被使用在如下场景：当拷贝一个结构体的代价过于昂贵时。考虑下一个结构体有很多的字段。
         在方法内使用这个结构体做为值接收器需要拷贝整个结构体，这是很昂贵的。
         在这种情况下使用指针接收器，结构体不会被拷贝，只会传递一个指针到方法内部使用。
         在其他的所有情况，值接收器都可以被使用。
     属于结构体的匿名字段的方法可以被直接调用，就好像这些方法是属于定义了匿名字段的结构体一样。
     在方法中使用值接收器 与 在函数中使用值参数：
         当一个函数有一个值参数，它只能接受一个值参数。
         当一个方法有一个值接收器，它可以接受值接收器和指针接收器。
     Go语言把 p.area() 解释为 (*p).area()。
     在方法中使用指针接收器 与 在函数中使用指针参数：
         和值参数相类似，函数使用指针参数只接受指针，而使用指针接收器的方法可以使用值接收器和指针接收器。
     Go语言把代码 r.perimeter() 解释为 (&r).perimeter()。
     在非结构体上的方法：
        为了在一个类型上定义一个方法，方法的接收器类型定义和方法的定义应该在同一个包中。
        为内置类型 int 创建一个类型别名，然后创建一个以该类型别名为接收器的方法。
        package main
        import "fmt"
        type myInt int
        func (a myInt) add(b myInt) myInt {
            return a + b
        }
        func main() {
            num1 := myInt(5)
            num2 := myInt(10)
            sum := num1.add(num2)
            fmt.Println("Sum is", sum)
        }
  
  11.接口
     在面向对象的领域里，接口一般这样定义：接口定义一个对象的行为。接口只指定了对象应该做什么，至于如何实现这个行为（即实现细节），则由对象本身去确定。
     在 Go 语言中，接口就是方法签名（Method Signature）的集合。当一个类型定义了接口中的所有方法，我们称它实现了该接口。
     接口指定了一个类型应该具有的方法，并由该类型决定如何实现这些方法。
     和其他语言（如 Java）很不同，其他一些语言要求一个类使用 implement 关键字，来显式地声明该类实现了接口。
     而在 Go 中，并不需要这样。如果一个类型包含了接口中声明的所有方法，那么它就隐式地实现了 Go 接口。
     我们可以把接口看作内部的一个元组 (type, value)。 type 是接口底层的具体类型（Concrete Type），而 value 是具体类型的值。
     没有包含方法的接口称为空接口。空接口表示为 interface{}。由于空接口没有方法，因此所有类型都实现了空接口。
     ----------------------------------------------------------------------------------------------------
     类型断言用于提取接口的底层值（Underlying Value）。
     在语法 i.(T) 中，接口 i 的具体类型是 T，该语法用于获得接口的底层值。
     v, ok := i.(T)
     如果 i 的具体类型是 T，那么 v 赋值为 i 的底层值，而 ok 赋值为 true。
     如果 i 的具体类型不是 T，那么 ok 赋值为 false，v 赋值为 T 类型的零值，此时程序不会报错。
     ----------------------------------------------------------------------------------------------------
     类型选择用于将接口的具体类型与很多 case 语句所指定的类型进行比较。
     它与一般的 switch 语句类似。唯一的区别在于类型选择指定的是类型，而一般的 switch 指定的是值。
     类型选择的语法类似于类型断言。类型断言的语法是 i.(T)，而对于类型选择，类型 T 由关键字 type 代替。
     还可以将一个类型和接口相比较。如果一个类型实现了接口，那么该类型与其实现的接口就可以互相比较。
     ----------------------------------------------------------------------------------------------------
     实现接口：指针接受者与值接受者
     我们在讨论方法的时候就已经提到过，使用值接受者声明的方法，既可以用值来调用，也能用指针调用。
     不管是一个值，还是一个可以解引用的指针，调用这样的方法都是合法的。
     我们曾经学习过，使用指针接受者的方法，无论指针还是值都可以调用它。那么为什么第 45 行的代码就不管用呢？
     其原因是：对于使用指针接受者的方法，用一个指针或者一个可取得地址的值来调用都是合法的。
     但接口中存储的具体值（Concrete Value）并不能取到地址，因此在第 45 行，对于编译器无法自动获取 a 的地址，于是程序报错。
     类型可以实现多个接口。
     接口的嵌套：尽管 Go 语言没有提供继承机制，但可以通过嵌套其他的接口，创建一个新接口。
     接口的零值是 nil。对于值为 nil 的接口，其底层值（Underlying Value）和具体类型（Concrete Type）都为 nil。
     对于值为 nil 的接口，由于没有底层值和具体类型，当我们试图调用它的方法时，程序会产生 panic 异常。
     
  12.并发入门和协程
     Go 是并发式语言，而不是并行式语言。
     并发是指立即处理多个任务的能力。并行是指同时处理多个任务。
     Go 编程语言原生支持并发。Go 使用 Go 协程（Goroutine） 和信道（Channel）来处理并发。
     Go 协程是与其他函数或方法一起并发运行的函数或方法。Go 协程可以看作是轻量级线程。与线程相比，创建一个 Go 协程的成本很小。
     因此在 Go 应用中，常常会看到有数以千计的 Go 协程并发地运行。
     Go 协程相比于线程的优势：
        1.相比线程而言，Go 协程的成本极低。堆栈大小只有若干 kb，并且可以根据应用的需求进行增减。而线程必须指定堆栈的大小，其堆栈是固定不变的。
        2.Go 协程会复用（Multiplex）数量更少的 OS 线程。即使程序有数以千计的 Go 协程，也可能只有一个线程。
          如果该线程中的某一 Go 协程发生了阻塞（比如说等待用户输入），那么系统会再创建一个 OS 线程，并把其余 Go 协程都移动到这个新的 OS 线程。
          所有这一切都在运行时进行，作为程序员，我们没有直接面临这些复杂的细节，而是有一个简洁的 API 来处理并发。
        3.Go 协程使用信道（Channel）来进行通信。信道用于防止多个协程访问共享内存时发生竞态条件（Race Condition）。
          信道可以看作是 Go 协程之间通信的管道。
     调用函数或者方法时，在前面加上关键字 go，可以让一个新的 Go 协程并发地运行。
     两个 Go 协程的主要性质：
         1.启动一个新的协程时，协程的调用会立即返回。与函数不同，程序控制不会去等待 Go 协程执行完毕。
           在调用 Go 协程之后，程序控制会立即返回到代码的下一行，忽略该协程的任何返回值。
         2.如果希望运行其他 Go 协程，Go 主协程必须继续运行着。如果 Go 主协程终止，则程序终止，于是其他 Go 协程也不会继续运行。
     
  13.信道
     通过信道来实现 Go 协程间的通信。
     信道可以想像成 Go 协程之间通信的管道。如同管道中的水会从一端流到另一端，通过使用信道，数据也可以从一端发送，在另一端接收。
     所有信道都关联了一个类型。信道只能运输这种类型的数据，而运输其他类型的数据都是非法的。chan T 表示 T 类型的信道。
     信道的零值为 nil。信道的零值没有什么用，应该像对 map 和切片所做的那样，用 make 来定义信道。
     简短声明通常也是一种定义信道的简洁有效的方法:
         a := make(chan int)
     如下所示，该语法通过信道发送和接收数据:
         data := <- a // 读取信道 a  
         a <- data // 写入信道 a
         信道旁的箭头方向指定了是发送数据还是接收数据。
         在第一行，箭头对于 a 来说是向外指的，因此我们读取了信道 a 的值，并把该值存储到变量 data。
         在第二行，箭头指向了 a，因此我们在把数据写入信道 a。
     发送与接收默认是阻塞的。
     当把数据发送到信道时，程序控制会在发送数据的语句处发生阻塞，直到有其它 Go 协程从信道读取到数据，才会解除阻塞。
     与此类似，当读取信道的数据时，如果没有其它的协程把数据写入到这个信道，那么读取过程就会一直阻塞着。
     信道的这种特性能够帮助 Go 协程之间进行高效的通信，不需要用到其他编程语言常见的显式锁或条件变量。
     <- done 这行代码通过信道 done 接收数据，但并没有使用数据或者把数据存储到变量中。这完全是合法的。
     使用信道需要考虑的一个重点是死锁。
     当 Go 协程给一个信道发送数据时，照理说会有其他 Go 协程来接收数据。如果没有的话，程序就会在运行时触发 panic，形成死锁。
     同理，当有 Go 协程等着从一个信道接收数据时，我们期望其他的 Go 协程会向该信道写入数据，要不然程序就会触发 panic。
     可以创建单向信道，这种信道只能发送或者接收数据。
     信道转换（Channel Conversion）
         把一个双向信道转换成唯送（Send Only）信道或者唯收（Receive Only）信道都是行得通的，但是反过来就不行。
     关闭信道和使用 for range 遍历信道：
         数据发送方可以关闭信道，通知接收方这个信道不再有数据发送过来。
         当从信道接收数据时，接收方可以多用一个变量来检查信道是否已经关闭。
             v, ok := <- ch
         上面的语句里，如果成功接收信道所发送的数据，那么 ok 等于 true。而如果 ok 等于 false，说明我们试图读取一个关闭的通道。
         从关闭的信道读取到的值会是该信道类型的零值。例如，当信道是一个 int 类型的信道时，那么从关闭的信道读取的值将会是 0。
         
  14.缓冲信道和工作池（Buffered Channels and Worker Pools）
     可以创建一个有缓冲（Buffer）的信道。只在缓冲已满的情况，才会阻塞向缓冲信道（Buffered Channel）发送数据。
     同样，只有在缓冲为空的时候，才会阻塞从缓冲信道接收数据。
     通过向 make 函数再传递一个表示容量的参数（指定缓冲的大小），可以创建缓冲信道。
         ch := make(chan type, capacity)
     要让一个信道有缓冲，上面语法中的 capacity 应该大于 0。无缓冲信道的容量默认为 0。
     注意死锁。
     缓冲信道的容量是指信道可以存储的值的数量。我们在使用 make 函数创建缓冲信道的时候会指定容量大小。
     缓冲信道的长度是指信道中当前排队的元素个数。
     WaitGroup：
        WaitGroup 用于实现工作池。因此要理解工作池，我们首先需要学习 WaitGroup。
        WaitGroup 用于等待一批 Go 协程执行结束。程序控制会一直阻塞，直到这些协程全部执行完毕。
        假设我们有 3 个并发执行的 Go 协程（由 Go 主协程生成）。Go 主协程需要等待这 3 个协程执行结束后，才会终止。这就可以用 WaitGroup 来实现。
     WaitGroup 是一个结构体类型。我们创建了 WaitGroup 类型的变量，其初始值为零值。WaitGroup 使用计数器来工作。
     当我们调用 WaitGroup 的 Add 并传递一个 int 时，WaitGroup 的计数器会加上 Add 的传参。
     要减少计数器，可以调用 WaitGroup 的 Done() 方法。Wait() 方法会阻塞调用它的 Go 协程，直到计数器变为 0 后才会停止阻塞。
     传递 wg 的地址是很重要的。如果没有传递 wg 的地址，那么每个 Go 协程将会得到一个 WaitGroup 值的拷贝，因而当它们执行结束时，main 函数并不会知道。
     工作池的实现：
         缓冲信道的重要应用之一就是实现工作池。
         一般而言，工作池就是一组等待任务分配的线程。一旦完成了所分配的任务，这些线程可继续等待任务的分配。
         我们工作池的核心功能如下：
            创建一个 Go 协程池，监听一个等待作业分配的输入型缓冲信道。
            将作业添加到该输入型缓冲信道中。
            作业完成后，再将结果写入一个输出型缓冲信道。
            从输出型缓冲信道读取并打印结果。
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
  
  
  
