Go基础知识：
  1.变量和常量
    基本类型：
        bool
        数字类型
          int8, int16, int32, int64, int
          uint8, uint16, uint32, uint64, uint
          float32, float64
          complex64, complex128
          byte
          rune
          byte 是 uint8 的别名。
          rune 是 int32 的别名。
        string
    Go 有着非常严格的强类型特征。Go 没有自动类型提升或类型转换。
    常量不能再重新赋值为其他的值。
    常量的值会在编译的时候确定。因为函数调用发生在运行时，所以不能将函数的返回值赋值给常量。
    常量没有任何类型。无类型的常量有一个与它们相关联的默认类型，并且当且仅当一行代码需要时才提供它。
    数字常量可以在表达式中自由混合和匹配，只有当它们被分配给变量或者在需要类型的代码中的任何地方使用时，才需要类型。
    
  2.函数和包
    多返回值、命名返回值、空白符
    包用于组织 Go 源代码，提供了更好的可重用性与可读性。
    属于某一个包的源文件都应该放置于一个单独命名的文件夹里。按照 Go 的惯例，应该用包名命名该文件夹。
    在 Go 中，任何以大写字母开头的变量或者函数都是被导出的名字。其它包只能访问被导出的函数和变量。
    所有包都可以包含一个 init 函数。init 函数不应该有任何返回值类型和参数，在我们的代码中也不能显式地调用它。
    init 函数可用于执行初始化任务，也可用于在开始执行之前验证程序的正确性。
    包的初始化顺序如下：
        首先初始化包级别（Package Level）的变量
        紧接着调用 init 函数。包可以有多个 init 函数（在一个文件或分布于多个文件中），它们按照编译器解析它们的顺序进行调用。
    如果一个包导入了另一个包，会先初始化被导入的包。尽管一个包可能会被导入多次，但是它只会被初始化一次。
    导入了包，却不在代码中使用它，这在 Go 中是非法的。当这么做时，编译器是会报错的。其原因是为了避免导入过多未使用的包，从而导致编译时间显著增加。
    然而，在程序开发的活跃阶段，又常常会先导入包，而暂不使用它。遇到这种情况就可以使用空白标识符 _。
    var _ = rectangle.Area 这一行屏蔽了错误。我们应该了解这些错误屏蔽器（Error Silencer）的动态，在程序开发结束时就移除它们，包括那些还没有使用过的包。
    由此建议在 import 语句下面的包级别范围中写上错误屏蔽器。
    有时候我们导入一个包，只是为了确保它进行了初始化，而无需使用包中的任何函数或变量。这种情况也可以使用空白标识符。
    
  3.if/else和循环和switch
    if 还有另外一种形式，它包含一个 statement 可选语句部分，该组件在条件判断之前运行。它的语法是
      if statement; condition {  
      }
    else 语句应该在 if 语句的大括号 } 之后的同一行中。如果不是，编译器会不通过。出错的原因是 Go 语言的分号是自动插入。
    在 Go 语言规则中，它指定在 } 之后插入一个分号，如果这是该行的最终标记。因此，在if语句后面的 } 会自动插入一个分号。
    ----------------------------------------------------------------------------------------------------
    for 是 Go 语言唯一的循环语句。Go 语言中并没有其他语言比如 C 语言中的 while 和 do while 循环。
    for initialisation; condition; post {  
    }
    这三个组成部分，即初始化，条件和 post 都是可选的。
    无限循环的语法是：
    for {  
    }
    ----------------------------------------------------------------------------------------------------
    switch 是一个条件语句，用于将表达式的值与可能匹配的选项列表进行比较，并根据匹配情况执行相应的代码块。
    它可以被认为是替代多个 if else 子句的常用方式。
    在选项列表中，case 不允许出现重复项。
    default 不一定只能出现在 switch 语句的最后，它可以放在 switch 语句的任何地方。
    在表达式求值之前，switch 可以选择先执行一个语句。
    多表达式判断：通过用逗号分隔，可以在一个 case 中包含多个表达式。
    无表达式的 switch：在 switch 语句中，表达式是可选的，可以被省略。这种类型的 switch 语句可以替代多个 if else 子句。
    如果省略表达式，则表示这个 switch 语句等同于 switch true，并且每个 case 表达式都被认定为有效，相应的代码块也会被执行。
    在 Go 中，每执行完一个 case 后，会从 switch 语句中跳出来，不再做后续 case 的判断和执行。
    使用 fallthrough 语句可以在已经执行完成的 case 之后，把控制权转移到下一个 case 的执行代码中。
    fallthrough 语句应该是 case 子句的最后一个语句。如果它出现在了 case 语句的中间，编译器将会报错：fallthrough statement out of place
    
  4.数组和切片
    数组是同一类型元素的集合。Go 语言中不允许混合不同类型的元素，如果是 interface{} 类型数组，可以包含任意类型。
    一个数组的表示形式为 [n]T。n 表示数组中元素的数量，T 代表每个元素的类型。元素的数量 n 也是该类型的一部分。
    可以使用不同的方式来声明数组：
        var a[3]int 声明了一个长度为 3 的整型数组。数组中的所有元素都被自动赋值为数组类型的零值。
        在这种情况下，a 是一个整型数组，因此 a 的所有元素都被赋值为 0，即 int 型的零值。
        简略声明：在简略声明中，不需要将数组中所有的元素赋值。
            a := [3]int{12, 78, 50}
            a := [3]int{12}
       甚至可以忽略声明数组的长度，并用 ... 代替，让编译器为你自动计算长度。
            a := [...]int{12, 78, 50}
       数组的大小是类型的一部分。因此 [5]int 和 [25]int 是不同类型。数组不能调整大小，不要担心这个限制，因为 slices 的存在能解决这个问题。
    Go 中的数组是值类型而不是引用类型。这意味着当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本。
    如果对新变量进行更改，则不会影响原始数组。同样，当数组作为参数传递给函数时，它们是按值传递，而原始数组保持不变。
    Go 提供了一种更好、更简洁的方法，通过使用 for 循环的 range 方法来遍历数组。range 返回索引和该索引处的值。
    如果你只需要值并希望忽略索引，则可以通过用 _ 空白标识符替换索引来执行。同样值也可以被忽略。
    这就是数组，尽管数组看上去似乎足够灵活，但是它们具有固定长度的限制，不可能增加数组的长度。这就要用到 切片 了。
    事实上，在 Go 中，切片比传统数组更常见。
    ----------------------------------------------------------------------------------------------------
    切片是由数组建立的一种方便、灵活且功能强大的包装（Wrapper）。切片本身不拥有任何数据。它们只是对现有数组的引用。
    带有 T 类型元素的切片由 []T 表示：
        a := [5]int{76, 77, 78, 79, 80}
        var b []int = a[1:4]
    另一种创建切片的方法：
        c := []int{6, 7, 8}
    切片自己不拥有任何数据。它只是底层数组的一种表示。对切片所做的任何修改都会反映在底层数组中。
    当多个切片共用相同的底层数组时，每个切片所做的更改将反映在数组中。
    切片的长度是切片中的元素数。切片的容量是从创建切片索引开始的底层数组中元素数。切片可以重置其容量。
    func make（[]T，len，cap）[]T 通过传递类型，长度和容量来创建切片。
    容量是可选参数, 默认值为切片长度。make 函数创建一个数组，并返回引用该数组的切片。
        i := make([]int, 5, 5)
    切片是动态的，使用 append 可以将新元素追加到切片上。append 函数的定义是 func append（s[]T，x ... T）[]T。
    x ... T 在函数定义中表示该函数接受参数 x 的个数是可变的。这些类型的函数被称为可变参数函数。
    当新的元素被添加到切片时，会创建一个新的数组。现有数组的元素被复制到这个新数组中，并返回这个新数组的新切片引用。现在新切片的容量是旧切片的两倍。
    切片类型的零值为 nil。一个 nil 切片的长度和容量为 0。可以使用 append 函数将值追加到 nil 切片。
    也可以使用 ... 运算符将一个切片添加到另一个切片。 
    切片包含长度、容量和指向数组第零个元素的指针。
    我们可以认为，切片在内部可由一个结构体类型表示。这是它的表现形式：
        type slice struct {  
            Length        int
            Capacity      int
            ZerothElement *byte
        }
    当切片传递给函数时，即使它通过值传递，指针变量也将引用相同的底层数组。
    内存优化：
        切片持有对底层数组的引用。只要切片在内存中，数组就不能被垃圾回收。在内存管理方面，这是需要注意的。
        假设我们有一个非常大的数组，我们只想处理它的一小部分。然后，我们由这个数组创建一个切片，并开始处理切片。
        这里需要重点注意的是，在切片引用时数组仍然存在内存中。
        一种解决方法是使用 copy 函数 func copy(dst，src[]T)int 来生成一个切片的副本。这样我们可以使用新的切片，原始数组可以被垃圾回收。
  
  5.可变参数函数
    可变参数函数是一种参数个数可变的函数。
    如果函数最后一个参数被记作 ...T ，这时函数可以接受任意个 T 类型参数作为最后一个参数。
    请注意只有函数的最后一个参数才允许是可变的。
    可变参数函数的工作原理是把可变参数转换为一个新的切片。
    有一个可以直接将切片传入可变参数函数的语法糖，你可以在在切片后加上 ... 后缀。如果这样做，切片将直接传入函数，不再创建新的切片。
    
  6.map
    map 是在 Go 中将值（value）与键（key）关联的内置类型。通过相应的键可以获取到值。
    通过向 make 函数传入键和值的类型，可以创建 map。make(map[type of key]type of value) 是创建 map 的语法。
    personSalary := make(map[string]int)
    map 的零值是 nil。如果你想添加元素到 nil map 中，会触发运行时 panic。因此 map 必须使用 make 函数初始化。
    也可以在声明的时候初始化 map:
        personSalary := map[string]int {
            "steve": 12000,
            "jamie": 15000,
        }
    键不一定只能是 string 类型。所有可比较的类型，如 boolean，interger，float，complex，string 等，都可以作为键。
    获取 map 元素的语法是 map[key]。获取一个不存在的元素，map 会返回该元素类型的零值。
    获取 map 中某个 key 是否存在的语法：
        value, ok := map[key]
    如果 ok 是 true，表示 key 存在，key 对应的值就是 value ，反之表示 key 不存在。
    遍历 map 中所有的元素需要用 for range 循环。有一点很重要，当使用 for range 遍历 map 时，不保证每次执行程序获取的元素顺序相同。
    删除 map 中 key 的语法是 delete(map, key)。这个函数没有返回值。
    获取 map 的长度使用 len 函数。
    和 slices 类似，map 也是引用类型。当 map 作为函数参数传递时也会发生同样的情况。函数中对 map 的任何修改，对于外部的调用都是可见的。
    map 之间不能使用 == 操作符判断，== 只能用来检查 map 是否为 nil。
    
  7.字符串
    由于和其他语言相比，字符串在 Go 语言中有着自己特殊的实现，因此在这里需要被特别提出来。
    Go 语言中的字符串是一个字节切片。把内容放在双引号""之间，我们可以创建一个字符串。Go 中的字符串是兼容 Unicode 编码的，并且使用 UTF-8 进行编码。
    在 UTF-8 编码中，一个代码点可能会占用超过一个字节的空间。rune 能帮我们解决这个难题。
    rune 是 Go 语言的内建类型，它也是 int32 的别称。在 Go 语言中，rune 表示一个代码点。代码点无论占用多少个字节，都可以用一个 rune 来表示。
    字符串使用 for range 循环。
    用字节切片构造字符串：
       byteSlice := []byte{0x43, 0x61, 0x66, 0xC3, 0xA9}
       str := string(byteSlice)
    用 rune 切片构造字符串
       runeSlice := []rune{0x0053, 0x0065, 0x00f1, 0x006f, 0x0072}
       str := string(runeSlice)
    utf8 package 包中的 func RuneCountInString(s string) (n int) 方法用来获取字符串的长度。
    Go 中的字符串是不可变的。一旦一个字符串被创建，那么它将无法被修改。
    为了修改字符串，可以把字符串转化为一个 rune 切片。然后这个切片可以进行任何想要的改变，然后再转化为一个字符串。
       s[0] = 'a' //any valid unicode character within single quote is a rune
   
  8.指针
    指针是一种存储变量内存地址（Memory Address）的变量。
    指针变量的类型为 *T，该指针指向一个 T 类型的变量。
    指针的零值是 nil。
    指针的解引用可以获取指针所指向的变量的值。将 a 解引用的语法是 *a。
    向函数传递指针参数：
        向函数传递一个数组指针参数，并在函数内修改数组。尽管它是有效的，但却不是 Go 语言惯用的实现方式。我们最好使用切片来处理。
    Go 并不支持其他语言（例如 C）中的指针运算。
  
  9.结构体
    结构体是用户定义的类型，表示若干个字段（Field）的集合。有时应该把数据整合在一起，而不是让这些数据没有联系。这种情况下可以使用结构体。
    命名的结构体：
       type Employee struct {
          firstName, lastName string
          age, salary         int
       }
    声明结构体时也可以不用声明一个新类型，这样的结构体类型称为 匿名结构体（Anonymous Structure）。
       var employee struct {
          firstName, lastName string
          age int
       }
    当定义好的结构体并没有被显式地初始化时，该结构体的字段将默认赋为零值。
    当然还可以为某些字段指定初始值，而忽略其他字段。这样，忽略的字段名会赋值为零值。
    点号操作符 . 用于访问结构体的字段。
    结构体的指针：
        Go 语言允许我们在访问 firstName 字段时，可以使用 emp8.firstName 来代替显式的解引用 (*emp8).firstName。
    当我们创建结构体时，字段可以只有类型，而没有字段名。这样的字段称为匿名字段（Anonymous Field）。
       type Person struct {  
          string
          int
       }
    虽然匿名字段没有名称，但其实匿名字段的名称就默认为它的类型。所以 Person 结构体有两个名为 string 和 int 的字段。
    结构体的字段有可能也是一个结构体。这样的结构体称为嵌套结构体。
    如果是结构体中有匿名的结构体类型字段，则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。
    如果结构体名称以大写字母开头，则它是其他包可以访问的导出类型（Exported Type）。同样，如果结构体里的字段首字母大写，它也能被其他包访问到。
    结构体是值类型。
    如果它的每一个字段都是可比较的，则该结构体也是可比较的。
    如果两个结构体变量的对应字段相等，则这两个变量也是相等的。
  
  10.方法
     方法其实就是一个函数，在 func 这个关键字和方法名中间加入了一个特殊的接收器类型。
     接收器可以是结构体类型或者是非结构体类型。接收器是可以在方法的内部访问的。
         func (t Type) methodName(parameter list) {
         } 
     Go 不是纯粹的面向对象编程语言，而且Go不支持类。因此，基于类型的方法是一种实现和类相似行为的途径。
     相同的名字的方法可以定义在不同的类型上，而相同名字的函数是不被允许的。
     指针接收器与值接收器：值接收器和指针接收器之间的区别在于，在指针接收器的方法内部的改变对于调用者是可见的，然而值接收器的情况不是这样的。
     Go语言让我们可以直接使用 e.changeAge(51)。e.changeAge(51) 会自动被Go语言解释为 (&e).changeAge(51)。
     一般来说，
         指针接收器可以使用在：对方法内部的接收器所做的改变应该对调用者可见时。
         指针接收器也可以被使用在如下场景：当拷贝一个结构体的代价过于昂贵时。考虑下一个结构体有很多的字段。
         在方法内使用这个结构体做为值接收器需要拷贝整个结构体，这是很昂贵的。
         在这种情况下使用指针接收器，结构体不会被拷贝，只会传递一个指针到方法内部使用。
         在其他的所有情况，值接收器都可以被使用。
     属于结构体的匿名字段的方法可以被直接调用，就好像这些方法是属于定义了匿名字段的结构体一样。
     在方法中使用值接收器 与 在函数中使用值参数：
         当一个函数有一个值参数，它只能接受一个值参数。
         当一个方法有一个值接收器，它可以接受值接收器和指针接收器。
     Go语言把 p.area() 解释为 (*p).area()。
     在方法中使用指针接收器 与 在函数中使用指针参数：
         和值参数相类似，函数使用指针参数只接受指针，而使用指针接收器的方法可以使用值接收器和指针接收器。
     Go语言把代码 r.perimeter() 解释为 (&r).perimeter()。
     在非结构体上的方法：
        为了在一个类型上定义一个方法，方法的接收器类型定义和方法的定义应该在同一个包中。
        为内置类型 int 创建一个类型别名，然后创建一个以该类型别名为接收器的方法。
        package main
        import "fmt"
        type myInt int
        func (a myInt) add(b myInt) myInt {
            return a + b
        }
        func main() {
            num1 := myInt(5)
            num2 := myInt(10)
            sum := num1.add(num2)
            fmt.Println("Sum is", sum)
        }
  
  11.接口
  
  
  
  
  
  
  
