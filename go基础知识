Go基础知识：
  1.变量和常量
    基本类型：
        bool
        数字类型
          int8, int16, int32, int64, int
          uint8, uint16, uint32, uint64, uint
          float32, float64
          complex64, complex128
          byte
          rune
          byte 是 uint8 的别名。
          rune 是 int32 的别名。
        string
    Go 有着非常严格的强类型特征。Go 没有自动类型提升或类型转换。
    常量不能再重新赋值为其他的值。
    常量的值会在编译的时候确定。因为函数调用发生在运行时，所以不能将函数的返回值赋值给常量。
    常量没有任何类型。无类型的常量有一个与它们相关联的默认类型，并且当且仅当一行代码需要时才提供它。
    数字常量可以在表达式中自由混合和匹配，只有当它们被分配给变量或者在需要类型的代码中的任何地方使用时，才需要类型。
    
  2.函数和包
    多返回值、命名返回值、空白符
    包用于组织 Go 源代码，提供了更好的可重用性与可读性。
    属于某一个包的源文件都应该放置于一个单独命名的文件夹里。按照 Go 的惯例，应该用包名命名该文件夹。
    在 Go 中，任何以大写字母开头的变量或者函数都是被导出的名字。其它包只能访问被导出的函数和变量。
    所有包都可以包含一个 init 函数。init 函数不应该有任何返回值类型和参数，在我们的代码中也不能显式地调用它。
    init 函数可用于执行初始化任务，也可用于在开始执行之前验证程序的正确性。
    包的初始化顺序如下：
        首先初始化包级别（Package Level）的变量
        紧接着调用 init 函数。包可以有多个 init 函数（在一个文件或分布于多个文件中），它们按照编译器解析它们的顺序进行调用。
    如果一个包导入了另一个包，会先初始化被导入的包。尽管一个包可能会被导入多次，但是它只会被初始化一次。
    导入了包，却不在代码中使用它，这在 Go 中是非法的。当这么做时，编译器是会报错的。其原因是为了避免导入过多未使用的包，从而导致编译时间显著增加。
    然而，在程序开发的活跃阶段，又常常会先导入包，而暂不使用它。遇到这种情况就可以使用空白标识符 _。
    var _ = rectangle.Area 这一行屏蔽了错误。我们应该了解这些错误屏蔽器（Error Silencer）的动态，在程序开发结束时就移除它们，包括那些还没有使用过的包。
    由此建议在 import 语句下面的包级别范围中写上错误屏蔽器。
    有时候我们导入一个包，只是为了确保它进行了初始化，而无需使用包中的任何函数或变量。这种情况也可以使用空白标识符。
    
  3.if/else和循环和switch
    if 还有另外一种形式，它包含一个 statement 可选语句部分，该组件在条件判断之前运行。它的语法是
      if statement; condition {  
      }
    else 语句应该在 if 语句的大括号 } 之后的同一行中。如果不是，编译器会不通过。出错的原因是 Go 语言的分号是自动插入。
    在 Go 语言规则中，它指定在 } 之后插入一个分号，如果这是该行的最终标记。因此，在if语句后面的 } 会自动插入一个分号。
    ----------------------------------------------------------------------------------------------------
    for 是 Go 语言唯一的循环语句。Go 语言中并没有其他语言比如 C 语言中的 while 和 do while 循环。
    for initialisation; condition; post {  
    }
    这三个组成部分，即初始化，条件和 post 都是可选的。
    无限循环的语法是：
    for {  
    }
    ----------------------------------------------------------------------------------------------------
    switch 是一个条件语句，用于将表达式的值与可能匹配的选项列表进行比较，并根据匹配情况执行相应的代码块。
    它可以被认为是替代多个 if else 子句的常用方式。
    在选项列表中，case 不允许出现重复项。
    default 不一定只能出现在 switch 语句的最后，它可以放在 switch 语句的任何地方。
    在表达式求值之前，switch 可以选择先执行一个语句。
    多表达式判断：通过用逗号分隔，可以在一个 case 中包含多个表达式。
    无表达式的 switch：在 switch 语句中，表达式是可选的，可以被省略。这种类型的 switch 语句可以替代多个 if else 子句。
    如果省略表达式，则表示这个 switch 语句等同于 switch true，并且每个 case 表达式都被认定为有效，相应的代码块也会被执行。
    在 Go 中，每执行完一个 case 后，会从 switch 语句中跳出来，不再做后续 case 的判断和执行。
    使用 fallthrough 语句可以在已经执行完成的 case 之后，把控制权转移到下一个 case 的执行代码中。
    fallthrough 语句应该是 case 子句的最后一个语句。如果它出现在了 case 语句的中间，编译器将会报错：fallthrough statement out of place
    
  4.数组和切片
    数组是同一类型元素的集合。Go 语言中不允许混合不同类型的元素，如果是 interface{} 类型数组，可以包含任意类型。
    一个数组的表示形式为 [n]T。n 表示数组中元素的数量，T 代表每个元素的类型。元素的数量 n 也是该类型的一部分。
    可以使用不同的方式来声明数组：
        var a[3]int 声明了一个长度为 3 的整型数组。数组中的所有元素都被自动赋值为数组类型的零值。
        在这种情况下，a 是一个整型数组，因此 a 的所有元素都被赋值为 0，即 int 型的零值。
        简略声明：在简略声明中，不需要将数组中所有的元素赋值。
            a := [3]int{12, 78, 50}
            a := [3]int{12}
       甚至可以忽略声明数组的长度，并用 ... 代替，让编译器为你自动计算长度。
            a := [...]int{12, 78, 50}
       数组的大小是类型的一部分。因此 [5]int 和 [25]int 是不同类型。数组不能调整大小，不要担心这个限制，因为 slices 的存在能解决这个问题。
    Go 中的数组是值类型而不是引用类型。这意味着当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本。
    如果对新变量进行更改，则不会影响原始数组。同样，当数组作为参数传递给函数时，它们是按值传递，而原始数组保持不变。
    Go 提供了一种更好、更简洁的方法，通过使用 for 循环的 range 方法来遍历数组。range 返回索引和该索引处的值。
    如果你只需要值并希望忽略索引，则可以通过用 _ 空白标识符替换索引来执行。同样值也可以被忽略。
    这就是数组，尽管数组看上去似乎足够灵活，但是它们具有固定长度的限制，不可能增加数组的长度。这就要用到 切片 了。
    事实上，在 Go 中，切片比传统数组更常见。
    ----------------------------------------------------------------------------------------------------
    切片是由数组建立的一种方便、灵活且功能强大的包装（Wrapper）。切片本身不拥有任何数据。它们只是对现有数组的引用。
    带有 T 类型元素的切片由 []T 表示：
        a := [5]int{76, 77, 78, 79, 80}
        var b []int = a[1:4]
    另一种创建切片的方法：
        c := []int{6, 7, 8}
    切片自己不拥有任何数据。它只是底层数组的一种表示。对切片所做的任何修改都会反映在底层数组中。
    当多个切片共用相同的底层数组时，每个切片所做的更改将反映在数组中。
    切片的长度是切片中的元素数。切片的容量是从创建切片索引开始的底层数组中元素数。切片可以重置其容量。
    func make（[]T，len，cap）[]T 通过传递类型，长度和容量来创建切片。
    容量是可选参数, 默认值为切片长度。make 函数创建一个数组，并返回引用该数组的切片。
        i := make([]int, 5, 5)
    切片是动态的，使用 append 可以将新元素追加到切片上。append 函数的定义是 func append（s[]T，x ... T）[]T。
    x ... T 在函数定义中表示该函数接受参数 x 的个数是可变的。这些类型的函数被称为可变参数函数。
    当新的元素被添加到切片时，会创建一个新的数组。现有数组的元素被复制到这个新数组中，并返回这个新数组的新切片引用。现在新切片的容量是旧切片的两倍。
    切片类型的零值为 nil。一个 nil 切片的长度和容量为 0。可以使用 append 函数将值追加到 nil 切片。
    也可以使用 ... 运算符将一个切片添加到另一个切片。 
    切片包含长度、容量和指向数组第零个元素的指针。
    我们可以认为，切片在内部可由一个结构体类型表示。这是它的表现形式：
        type slice struct {  
            Length        int
            Capacity      int
            ZerothElement *byte
        }
    当切片传递给函数时，即使它通过值传递，指针变量也将引用相同的底层数组。
    内存优化：
        切片持有对底层数组的引用。只要切片在内存中，数组就不能被垃圾回收。在内存管理方面，这是需要注意的。
        假设我们有一个非常大的数组，我们只想处理它的一小部分。然后，我们由这个数组创建一个切片，并开始处理切片。
        这里需要重点注意的是，在切片引用时数组仍然存在内存中。
        一种解决方法是使用 copy 函数 func copy(dst，src[]T)int 来生成一个切片的副本。这样我们可以使用新的切片，原始数组可以被垃圾回收。
  
  5.可变参数函数
    可变参数函数是一种参数个数可变的函数。
    如果函数最后一个参数被记作 ...T ，这时函数可以接受任意个 T 类型参数作为最后一个参数。
    请注意只有函数的最后一个参数才允许是可变的。
    可变参数函数的工作原理是把可变参数转换为一个新的切片。
    有一个可以直接将切片传入可变参数函数的语法糖，你可以在在切片后加上 ... 后缀。如果这样做，切片将直接传入函数，不再创建新的切片。
    
  6.map
    map 是在 Go 中将值（value）与键（key）关联的内置类型。通过相应的键可以获取到值。
    通过向 make 函数传入键和值的类型，可以创建 map。make(map[type of key]type of value) 是创建 map 的语法。
    personSalary := make(map[string]int)
    map 的零值是 nil。如果你想添加元素到 nil map 中，会触发运行时 panic。因此 map 必须使用 make 函数初始化。
    也可以在声明的时候初始化 map:
        personSalary := map[string]int {
            "steve": 12000,
            "jamie": 15000,
        }
    键不一定只能是 string 类型。所有可比较的类型，如 boolean，interger，float，complex，string 等，都可以作为键。
    获取 map 元素的语法是 map[key]。获取一个不存在的元素，map 会返回该元素类型的零值。
    获取 map 中某个 key 是否存在的语法：
        value, ok := map[key]
    如果 ok 是 true，表示 key 存在，key 对应的值就是 value ，反之表示 key 不存在。
    遍历 map 中所有的元素需要用 for range 循环。有一点很重要，当使用 for range 遍历 map 时，不保证每次执行程序获取的元素顺序相同。
    删除 map 中 key 的语法是 delete(map, key)。这个函数没有返回值。
    获取 map 的长度使用 len 函数。
    和 slices 类似，map 也是引用类型。当 map 作为函数参数传递时也会发生同样的情况。函数中对 map 的任何修改，对于外部的调用都是可见的。
    map 之间不能使用 == 操作符判断，== 只能用来检查 map 是否为 nil。
    
  7.字符串
    由于和其他语言相比，字符串在 Go 语言中有着自己特殊的实现，因此在这里需要被特别提出来。
    Go 语言中的字符串是一个字节切片。把内容放在双引号""之间，我们可以创建一个字符串。Go 中的字符串是兼容 Unicode 编码的，并且使用 UTF-8 进行编码。
    在 UTF-8 编码中，一个代码点可能会占用超过一个字节的空间。rune 能帮我们解决这个难题。
    rune 是 Go 语言的内建类型，它也是 int32 的别称。在 Go 语言中，rune 表示一个代码点。代码点无论占用多少个字节，都可以用一个 rune 来表示。
    字符串使用 for range 循环。
    用字节切片构造字符串：
       byteSlice := []byte{0x43, 0x61, 0x66, 0xC3, 0xA9}
       str := string(byteSlice)
    用 rune 切片构造字符串
       runeSlice := []rune{0x0053, 0x0065, 0x00f1, 0x006f, 0x0072}
       str := string(runeSlice)
    utf8 package 包中的 func RuneCountInString(s string) (n int) 方法用来获取字符串的长度。
    Go 中的字符串是不可变的。一旦一个字符串被创建，那么它将无法被修改。
    为了修改字符串，可以把字符串转化为一个 rune 切片。然后这个切片可以进行任何想要的改变，然后再转化为一个字符串。
       s[0] = 'a' //any valid unicode character within single quote is a rune
   
  8.指针
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
